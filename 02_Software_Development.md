# 통합 구현, 패키징

<br>

## 통합 구현

- 소프트웨어를 **작은 단위**로 개발 후 이들을 **통합**하여 하나의 시스템으로 만드는 과정

### 1. 단위 모듈

- 모듈화의 원리에 기반
- #### 핵심원리 4가지
    - #### 분할과 지배
      - 복잡한 문제를 작게 나눠 해결
    - #### 정보 은닉
      - 내부 구조를 숨기고 인터페이스만 공개
    - #### 자료 추상화
      - 불필요한 세부정보는 숨기고 필요한 기능만 노출
    - #### 모듈의 독립성
      - 각 모듈은 다른 모듈과 최소한만 연결
  
### 2. IDE (통합 개발 환경)

- Intergrated Development Enviroment
- 코드 작성, 컴파일, 디버깅 등을 한 환경에서 지원
- 예시 : Visual Studio, Eclipse, IntelliJ, PyCharm 등
  
### 3. 빌드 자동화 도구

- 소스코드를 자동으로 컴파일, 테스트, 패키징 해주는 도구

- 주요 도구 : Gradle, JenKins, Makefile, Ant, Maven

- 소스코드를 넣으면 자동으로 실행파일이나 배포파일 생성

<br>

## 패키징

- 완성된 소프트웨어를 배포 가능한 형태로 포장하는 과정

### 1. 고려사항

- 배포시 반드시 확인할 점
    - 실행환경(플랫폼 호환성)
    - 보안 요소
    - 성능 및 용량
    - 사용자의 접근성

### 2. 모니터링 도구

- APM (Application Performance Management)
    - 시스템 동작을 실시간으로 감시
    - 병목 현상, 오류 등을 분석
    - 대표 : Datadog, New Relic, Pinpoint

### 3. DRM 기술 요소

- Digital Rights Management
- 소프트웨어/콘텐츠 보호 기술
- 주요 기능 : 
  - 암호화
  - 키 관리
  - 암호화 파일 생성
  - 식별 기술 : 사용자나 장치 확인
  - 정책 관리, 크랙 방지, 인증

### 4. DRM 구성

- 구성요소 :
  - 제공자(콘텐츠 제작자)
  - 분배자(배포 플랫폼)
  - 패키저(암호화 및 포장 담당)
  - 보안 컨테이너
  - 컨트롤러
  - 클리어링하우스 (정산 및 권한 처리 시스템)

<br>

# SW 품질목표, 메뉴얼

## 1. SW 품질목표

- 소프트웨어가 만족해야 할 품질적 기준
- 총 10가지 요소

| 품질 목표 | 설명 |
| --- | --- |
| 정확성 | 프로그램이 의도한 대로 동작 |
| 신뢰성 | 고장 없이 오랫동안 안정적으로 작동 |
| 효율성 | 자원을 낭비하지 않고 빠르고 효율적으로 작동 |
| 무결성 | 데이터가 외부 위협이나 오류로부터 보호됨 |
| 이식성 | 다양한 환경에서 잘 작동 |
| 상호운용성 | 다른 시스템과 잘 연결되고 호환됨 |
| 재사용성 | 다른 프로젝트에서 코드를 재활용 가능 | 
| 유지보수성 | 문제가 생기면 쉽게 수정 및 개선 가능 |
| 유연성 | 요구사항이 변해도 쉽게 수정 가능 |
| 시험 역량 | 테스트가 쉽고 체계적으로 가능해야 함 |

## 2. 매뉴얼

- 소프트웨어 사용과 설치를 도와주는 설명서

### 사용자 매뉴얼

- 작성 순서
  - 지침 정의 (어떤 목적/대상인지 명확히)
  - 구성요소 정의 (항목별 제목/내용 정리)
  - 구성요소별 작성 (본문 내용 작성)
  - 매뉴얼 검토 (오타, 문맥, 누락 등 확인)

### 설치 매뉴얼

- 기본사항
  - 개요
  - 관련 파일
  - 설치 아이콘
  - 프로그램 삭제 방법
  - 추가 정보

- 작성 프로세스
  - 지침 정의
  - 구성요소 정의
  - 구성요소별 내용 작성
  - 매뉴얼 검토

<br>

# 형상 관리

- 소프트웨어 개발 과정에서 모든 문서와 코드의 상태를 체계적으로 기록하고 관리하는 일

## 1. 항목

| 항목 종류 | 설명 |
| --- | --- |
| 요구분석서 | 고객이 원하는 기능 정리 |
| 운영 설치 지침서 | 소프트웨어를 어떻게 설치하고 운영하는지 설명 |
| 요구사항 명세서 | 소프트웨어가 충족해야하는 세부 요건을 정리 |
| 설계/인터페이스 명세서 | 시스템 설계 및 컴포넌트 간 연결 방식을 기술 |
| 테스트 설계서 | 어떤 방법으로 테스트할지 계획 |
| 품질 보증 계획서 | 품질 목표를 달성하기 위한 계획 |
| 형상 관리 계획서 | 형상 관리 활동을 위한 세부 계획 |
| V&V 계획서 | 검증과 확인을 통해 활동을 어떻게 수행할지 계획 |
| 코드 모듈 | 작성된 실제 소스 코드 |

- #### 핵심 요약 : 
  - 소프트웨어를 만들면서 생기는 모든 산출물은 모두 관리 대상

## 2. 개념

| 개념 | 설명 |
| --- | --- |
| 캡슐화 | 관련 데이터를 하나의 단위로 묶어 관리 |
| 정보 은닉 | 꼭 필요한 정보만 노출하고, 나머지는 숨긴다 |
| 추상화 | 복잡한 세부사항은 숨기고 핵심만 |
| 상속성 | 기존 형상을 물려받아 새롭게 추가/수정 |
| 다형성 | 같은 인터페이스로 다양한 동작 가능 |

## 3. 절차

| 절차 | 설명 |
| --- | --- |
| 식별 | 관리할 대상을 고유하게 지정 |
| 통제 | 변경사항을 승인하고 관리 |
| 보고 및 감사 | 변경된 내용과 상태를 기록하고 감사 |
| 기록 보고 | 결과를 문서화하고 보고 |

- 무엇을 관리할지 정하고, 변화 감시, 기록, 나중에 점검

## 4. 도구

### 공유 폴더

- 팀원끼리 파일을 공유하는 가장 기본적인 방법
- 변경 이력을 남기기 어렵고 충돌이 많음

### 클라이언트 / 서버

- 서버에 형상 관리 도구를 설치하고, 클라이언트가 접속해 파일을 관리
- GitLab, SVN 서버 등

### 분산 저장소

- 각 사용자가 자신의 로컬에 저장소를 가지고 관리
- 대표적인 예: Git
- 오프라인에서 작업 가능, 나중에 서버에 push

### 주요 도구

| 도구 | 특징 |
| --- | --- |
| CVS(Concurrent Versions System) | 예전부터 쓰이던 버전 관리 시스템 |
| RCS(Revision Control System) | 초기 버전 관리 시스템 |
| SVN(Subversion) | CVS보다 발전된 중앙 집중식 버전 관리 |
| BitKeeper | 리눅스 커널 개발 초기에 사용된 분산형 버전 관리 |
| Git | 현재 가장 많이 사용하는 분산형 버전 관리 시스템 |
| ClearCase | IBM에서 만든 고급 형상 관리 도구 |

### 명령어

| 명령어 | 의미 |
| --- | --- |
| check-in | 변경 사항을 서버에 반영 |
| check-out | 서버에서 파일을 받아오기 |
| commit | 작업 내용을 저장소에 확정 저장하기 |

# 알고리즘, 인터페이스 구현

<br>

## 1. 알고리즘

- 어떻게 설계할 것인가? 에 대한 전략들

| 기법 이름 | 설명 |
| --- | --- |
| 분할 정복법 | 문제를 작게 나눠서 해결 후 합치기 |
| 동적 계획법 | 중복 계산을 줄이고 결과를 저장하여 효율적으로 계산 |
| 탐욕법 | 매 간 최선의 선택 |
| 퇴각 검색법 | 잘못된 길이면 되돌아가서 다시 탐색 |
| 분기 한정법 | 경우의 수를 계산하되 유망한 경우만 확장 |
| 근사 해법 | 정확하진 않지만 빠르고 그럴싸한 해 |

## 2. 시간 복잡도

- 알고리즘 성능을 수학적으로 분석한 것
- 대표 표현 : O(log n), O(n), O(n^2) 등

| 알고리즘 | 복잡도 | 설명 |
| --- | --- | --- |
| 퀵 정렬 | O(n logn) | 평균적으로 빠름, 분할 정복 기반 |
| 병합 정렬 | O(n logn) | 안정 정렬, 메모리 많이 씀 |
| 선택 정렬 | O(n^2) |  느리지만 구조는 간단 |

## 3. 순환 복잡도

- 프로그램의 분기(조건문, 반복문)가 많아질수록 복잡도 증가

- 수식 V(G) = E - N + 2
  - E : 간선 , N : 노드

- 프로그램 흐름도를 그래프로 보고 얼마나 복잡하게 꼬였는지를 수치로 나타내는 것
- 조건문 많고 if, for, while 많으면 V(G)가 커짐 -> 테스트도 더 어려움

## 4. 클린 코드

- 작성 원칙
  - 가독성 : 읽기 쉽게
  - 단순성 : 복잡하게 꼬지 말고
  - 의존성 배제 : 너무 많은 외부 참조 피하기
  - 중복 최소화, 추상화 등

- 좋은 코드란, 다른 사람이 읽고 바로 이해할 수 있는 코드

## 5. 소스 코드 품질 분석

### 외적인 코드 품질
  - 겉으로 보기에 잘 정돈된 코드

### 정적 분석 도구
  - 코드 실행 없이 소스 자체만으로 오류/문제 파악
  - pmd, cppcheck, SonarQube
### 동적 분석 도구
  - 코드를 실행하면서 품질 점검
  - checkstyle, ccm, cobertura
    - cmm : 복잡도 측정, cobertura : 테스트 커버리지 측정

## 6. 인터페이스 구현

### 1. 모듈 연계

  - 모듈 간 통식 방식 : 데이터를 어떻게 주고받을지 결정

| 유형 | 설명 |
| --- | --- |
| Point to Point | 직접 연결. 단순하지만 관리 어려움 |
| Hub & Spoke | 중앙 허브가 모든 연결 관리 |
| Message Bus | 메시지 기반 비동기 통신 |
| Hybrid | 위 방식들을 혼합 |
| ESB(Enterprise Service Bus) | 대규모 시스템 통합 방식 |

### 2. 연계 표준

- 시스템 간 데이터 전달 시 사용 방식

| 표준 | 설명 |
| --- | --- |
| AJAX | 웹에서 비동기 통신 |
| JSON | 가볍고 많이 쓰는 데이터 포맷 |

### 3. 검증 도구

- 인터페이스 테스트할 때 자동화 도구

| 도구 | 설명 |
| --- | --- |
| Watir, Selenium | 웹 브라우저 자동화 |
| xUnit, FitNesse, STAF, NTAF | 테스트 자동화 프레임워크 |

### 4. 보안

| 계층 | 보안 방식 |
| --- | --- |
| 전송 계층 | IPSec AH |
| 응용 계층 | SSL, S-HHTP |
