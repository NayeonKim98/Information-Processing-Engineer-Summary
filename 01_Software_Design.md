# 📘 소프트웨어 공학 정리 (정보처리기사 1과목)

<br>

## 1. 설계 방법론 (Software Design Methodologies)

* **HIPO**
  * 위계 구조 + IPO(입력/처리/출력)
  * 비유: 회사 조직도처럼 큰 구조 먼저 보여주기

* **V 모델**
  * 개발과 테스트를 병렬로 계획
  * 비유: 제품 조립과 품질 테스트를 동시에 진행

* **나선형 모델 (Spiral Model)**
  * 반복 개발 + 위험 분석
  * 비유: 위험을 줄여가며 나선형으로 올라가는 계단

* **상향식**
  * 작은 모듈부터 조립 → 큰 시스템
  * 비유: 블록 하나씩 쌓기

* **하향식**
  * 큰 설계 먼저 → 하위 구현
  * 비유: 설계도부터 그리는 건축

* **Agile(애자일)**
  * 핵심: 빠른 피드백, 문서 최소화, 변화 수용

  * Agile 선언문:
    * 문서화보다 **작동하는 소프트웨어**
    * 계약보다 **고객과 협력**
    * 계획보다 **변화에 대응**
  
  * 종류:
    * **SCRUM**: 스프린트 단위 반복 개발
    * **XP (Extreme Programming)**:
      * ① 12가지 실천사항
      * ② 5가지 핵심 가치 (용기, 피드백, 단순성 등)

<br>

## 2. CASE (Computer-Aided Software Engineering)

* **CASE 도구**
  * 설계, 개발, 테스트를 지원하는 소프트웨어 공구
  
* **CASE 분류**
  * 상위 CASE: 분석, 설계 지원
  * 하위 CASE: 구현, 테스트 지원
  * 통합 CASE: 전체 과정 지원

<br>

## 3. 재공학 (Re-engineering)

* 기존 시스템을 해체 없이 **리모델링**
* 목적: 성능 개선, 유지보수성 향상
* 비유: 낡은 건물 내부를 리모델링하는 것

<br>

## 4. 시스템 구성 요소

* **입력(Input)**: 사용자/외부로부터 데이터 입력 (ex. 키보드)
* **처리(Process)**: 데이터 처리 및 계산 (ex. CPU 연산)
* **출력(Output)**: 처리 결과를 외부로 보여줌 (ex. 모니터)
* **제어(Control)**: 흐름 제어 (조건문, 반복문 등)
* **피드백(Feedback)**: 결과를 다시 입력으로 사용 (ex. AI 학습 구조)

<br>

## 요약 표

| 구분 | 핵심 키워드 | 설명 요약 |
|--------------|-----------------------------------------|-----------------------------------|
| 설계 방법론 | HIPO, V모델, 나선형, 상향식/하향식, Agile | 다양한 시스템 설계 전략 |
| Agile | SCRUM, XP | 유연하고 빠른 반복적 개발 방식 |
| CASE | 도구, 분류(상위/하위/통합) | 개발과정 자동화 도구 |
| 재공학 | 리팩토링, 성능 개선 | 기존 시스템을 효율적으로 개선 |
| 시스템 구성 | 입력, 처리, 출력, 제어, 피드백 | 컴퓨터 시스템의 기본 동작 구조 |

<br>

# 📘 UML 정리 (정보처리기사 1과목 - 소프트웨어 설계)

<br>

## 1. UML이란?
* Unified Modeling Language
* 복잡한 시스템을 **시각적으로 설계**하기 위한 표준 모델링 언어
* 정적 구조부터 동적 동작까지 **다양한 관점의 다이어그램** 제공

<br>

## 2. 행위 다이어그램 (Behavior Diagram)

* 시스템의 **동작, 상호작용, 상태 변화**를 표현

### 상호작용(Interaction)
* 객체들 사이의 **메시지 교환 흐름**을 표현
* 종류:
  * **순차 다이어그램(Sequence)**: 시간 흐름에 따른 메시지
  * **커뮤니케이션 다이어그램**: 객체 간 연결 중심
  * **타이밍 다이어그램**: 시간 제약을 포함한 상호작용

### 유스케이스(Use Case)
* **사용자 관점에서 시스템이 수행해야 할 기능**
* "사용자가 무얼 할 수 있나?"를 표현
* 비유: '시스템 메뉴판'

### 활동 다이어그램(Activity)
* 작업 흐름(Work Flow), 로직 분기, 병렬 처리 등 **프로세스 흐름** 표현

### 상태 머신(State Machine)
* 객체가 특정 **상태에서 다른 상태로 전이**되는 과정을 표현
* 예: 로그인 상태 → 인증 상태 → 사용 중 상태

### 협업 다이어그램(Collaboration)
* 객체들 간의 **역할과 협력 관계**를 표현

<br>

## 3. 구조 다이어그램 (Structure Diagram)

* 시스템의 **정적 구조**, 구성 요소 간의 관계를 표현

### 클래스(Class) 다이어그램
* 가장 기본적인 구조 다이어그램
* **객체의 속성, 메서드, 관계**를 표현

#### 클래스 간 주요 관계
* **연관 관계**: 실선 (A와 B가 연결됨)
* **의존 관계**: 점선 화살표 (B가 A를 참조만)
* **일반화 관계**: 삼각형 화살표 (상속)
* **집합 관계**: 빈 마름모 (전체-부분 관계)
* **포함 관계**: 채운 마름모 (강한 전체-부분)
* **실체/인터페이스 관계**: 구현(이탤릭체)

### 복합체 구조(Composite Structure)
* 클래스 내부 구성이나 협력 구조를 나타냄 (클래스 내부의 구성요소 표현)

### 배치(Diagram)
* **하드웨어 상에서 소프트웨어가 어떻게 배치되는가**
* 서버, 노드, DB 등 실제 배포 구조 표현

### 컴포넌트(Component)
* **코드의 모듈 단위(컴포넌트)** 간의 의존 관계
* 예: 모듈 간 API 연결

### 패키지(Package)
* 여러 클래스를 **그룹화**하여 큰 구조를 단순화
* 비유: 폴더처럼 관련 클래스들을 묶는 기능

<br>

## 4. 럼바우 기법 (Rumbaugh Method)

* 객체지향 설계 대표 기법 중 하나
* 구성 요소:
  * **객체 모델(Object Model)** → 정적 구조
  * **동적 모델(Dynamic Model)** → 상태 전이, 이벤트 흐름
  * **기능 모델(Functional Model)** → 데이터 흐름과 처리

<br>

## 요약 표

| 구분 | 다이어그램 종류 | 설명 요약 |
|----------------|-----------------------------|-----------|
| 행위 다이어그램 | 유스케이스, 활동, 상태머신, 상호작용, 협업 | 시스템 동작과 흐름 중심 |
| 구조 다이어그램 | 클래스, 복합체, 배치, 컴포넌트, 패키지 | 시스템 구성과 관계 표현 |
| 럼바우 기법 | 객체/동적/기능 모델 | 객체지향 설계 접근 방식 |

<br>

# 📘 요구사항 개발 & UI 정리 (정보처리기사 1과목 - 소프트웨어 설계)

<br>

## 1. 요구사항 개발 (Requirement Development)

* 사용자가 **무엇을 원하는지**, **시스템이 어떤 기능을 해야 하는지** 정의하는 단계

### SWEBOK 요구개발 프로세스
* 국제 소프트웨어 지식 체계(SWEBOK)에서 제시한 **요구사항 개발의 단계적 절차**

### 요구사항 분석
* 요구사항을 구체적으로 **분석하고 추출**하는 과정
* 분석 기법 활용 (ex. 인터뷰, 워크숍, 설문 등)

### 요구사항 분류
* **기능적 요구사항**: 시스템이 제공해야 할 기능
  * 예: 로그인 기능, 상품 검색 기능
* **비기능적 요구사항**: 성능, 보안, 사용성 등 품질 요구
  * 예: 응답 시간은 1초 이내, 하루 10만명 처리

### 요구사항 명세
* 수집된 요구사항을 문서화
* 개발자와 사용자 간 **명확한 합의 문서**

<br>

## 2. UI 설계 (User Interface Design)

### 설계 지침 (UI Design Principles)
* 좋은 UI를 만들기 위한 기준

* 주요 항목:
  * **사용자 중심성**: 사용자가 쉽게 이해하고 쓸 수 있도록
  * **일관성**: 페이지마다 스타일, 위치가 일정해야 함
  * **단순성**: 복잡한 UI보다 쉬운 인터페이스
  * **가시성**: 중요한 정보를 눈에 띄게
  * **표준화**: 공통된 규칙 사용
  * **접근성**: 장애가 있어도 접근 가능
  * **명확성**: 명확한 문구, 에러 메시지 제공
  * **오류 방지와 해결**: 잘못된 입력을 방지하고, 에러 시 해결 방법 제공

### 웹 콘텐츠 접근성 지침
* 모든 사람이 웹 콘텐츠를 **쉽게 사용할 수 있도록**

* 4가지 용이성 원칙:
  * **인식의 용이성**: 정보를 감지할 수 있게
  * **운용의 용이성**: 키보드, 마우스로 조작 가능해야
  * **이해의 용이성**: 콘텐츠와 UI를 쉽게 이해할 수 있게
  * **견고성**: 보조 기술과 잘 작동하도록

### 설계 원칙
* UI 시스템을 구축할 때의 **기본 철학**

* 구성 요소:
  * **유효성**: 실제 사용 목적에 부합
  * **직관성**: 처음 봐도 기능이 예측 가능
  * **학습성**: 금방 익힐 수 있음
  * **유연성**: 다양한 사용자가 사용할 수 있음

---

## 요약 표

| 구분 | 핵심 키워드 | 설명 요약 |
|-----------------|----------------------------------------------|----------------------------------------|
| 요구사항 개발 | 분석, 분류(기능/비기능), 명세 | 사용자 요구사항을 정의하고 문서화 |
| UI 설계 지침 | 사용자 중심, 일관성, 단순성, 가시성, 오류해결 | 사용성이 높은 UI를 위한 일반 원칙 |
| 접근성 지침 | 인식성, 운용성, 이해성, 견고성 | 장애인 포함 모두가 접근 가능한 콘텐츠  |
| 설계 원칙 | 유효성, 직관성, 학습성, 유연성 | 효과적이고 학습 가능한 UI 설계 기준 |

<br>

# 📘 코드 설계 & 구조적 분석 도구 (정보처리기사 1과목 - 소프트웨어 설계)

<br>

## 1. 코드 설계 (Code Design)

### 구조도
* **Fan-in**: 여러 모듈이 하나의 모듈을 호출
* **Fan-out**: 하나의 모듈이 여러 모듈을 호출  
* 설계 시 Fan-in은 **높을수록**, Fan-out은 **낮을수록** 좋음

### 코드 종류
* **순차 구조**: 위 → 아래 순서대로 실행
* **포의숫자 구조**: 조건 판단하여 분기 (ex. if문, switch)
* **블록 구조**: 관련 명령어를 묶어서 실행
* **그룹 분류식**: 유사한 기능을 묶어 설계

### 코드 오류 유형
* **필시 오류**: 잘못된 표기나 문법 오류
* **전위 오류**: 연산 순서 문제
* **생략 오류**: 빠뜨린 코드
* **임의 오류**: 필요 없는 코드 삽입
* **추가 오류**: 중복된 코드
* **이중 오류**: 논리 중복

<br>

## 2. 구조적 분석 도구 (Structured Analysis Tools)

### 자료 흐름도(DFD, Data Flow Diagram)
* 시스템 내에서 **데이터가 흐르는 경로**를 시각적으로 표현

#### 도형 의미
* **프로세스(원)**: 처리 단계
* **자료 흐름(화살표)**: 데이터 이동
* **자료 저장소(= 상자)**: 파일 또는 DB 등
* **단말(사각형)**: 외부 엔티티

#### 기호 요약
* `=` : 정의  
* `+` : 연결  
* `()` : 생략  
* `[ ]` : 선택  
* `{ }` : 반복  
* `**` : 주석

### 자료 사전(Data Dictionary)
* 시스템에서 사용되는 **데이터에 대한 정의 모음**
* 각 자료 흐름의 의미, 형식, 단위, 제약사항 등을 문서화

<br>

## 요약 표

| 구분 | 핵심 키워드 | 설명 요약 |
|--------------------|-------------------------------------|-------------------------------------------------|
| 구조도 | Fan-in, Fan-out | 모듈 간 호출 관계를 시각화 |
| 코드 종류 | 순차, 조건, 블록, 그룹 | 코드의 실행 흐름 또는 설계 패턴 |
| 코드 오류 | 필시, 전위, 생략, 임의, 추가, 이중 | 설계 또는 구현 시 발생하는 주요 오류 유형들    |
| 자료 흐름도 (DFD)  | 프로세스, 화살표, 상자, 사각형 | 시스템의 데이터 흐름을 도식화하여 분석 |
| 자료 사전 | 정의서, 연결 기호 등 | 데이터 구조 및 흐름의 세부 내용 정리 |

<br>

# 📘 모듈 & SW 아키텍처 정리 (정보처리기사 1과목 - 소프트웨어 설계)

<br>

## 1. 모듈 (Module)

* 모듈화의 목적:  
  - 복잡도 감소  
  - 중복성 줄이기  
  - 일관성 유지  
  - 응집도는 **높이고**, 결합도는 **낮추기**

### 설계 방법
* **오류를 줄이고**, **재사용성과 유지보수성**을 높이기 위한 설계 전략

### 결합도(Coupling) – 약할수록 좋음
* 모듈 간 **의존도** 수준을 나타냄
* 결합도 종류 (약한 → 강한 순):
  - **자료 결합**: 필요한 데이터만 전달 (✅ 가장 바람직)
  - **스탬프 결합**: 자료구조 전체 전달
  - **제어 결합**: 제어신호 전달
  - **외부 결합**: 외부 장치나 인터페이스 공유
  - **공통 결합**: 전역 변수 사용
  - **내용 결합**: 한 모듈이 다른 모듈 내부를 참조 (❌ 최악)

### 응집도(Cohesion) – 강할수록 좋음
* 하나의 모듈이 **얼마나 한 가지 기능에 집중**되어 있는가

* 응집도 종류 (약한 → 강한 순):
  - **기능적 응집**(✅ 이상적): 하나의 기능만 수행
  - **순차적 응집**: 출력이 다음 처리의 입력
  - **교환적 응집**: 비슷한 기능 묶음
  - **절차적 응집**: 순서만 동일
  - **시간적 응집**: 동시에 실행됨
  - **논리적 응집**: 유사한 기능 모임
  - **우연적 응집**(❌ 최악): 무작위로 묶인 모듈

### 공통 모듈 명세
* 명확하고 일관된 **정의**, **명세**, **완전성**, **추적성** 확보가 중요

<br>

## 2. SW 아키텍처 (Software Architecture)

### 아키텍처 패턴
* 시스템 구조 설계 시 활용되는 **대표적 구조 방식**

* 주요 패턴:
  - **계층형**: 계층 구조 (예: OSI 7계층)
  - **MVC (Model-View-Controller)**: 웹 프레임워크의 대표 구조
  - **클라이언트-서버**: 서버가 중앙 처리, 클라이언트가 요청
  - **파이프 필터**: 데이터 흐름 기반 (필터: 처리 / 파이프: 전달)
  - **Peer to Peer (P2P)**: 중앙 없이 서로 연결
  - **브로커**: 중재자가 통신 중개
  - **블랙보드**: 공통 데이터 공간 공유

### 품질 속성
* 좋은 소프트웨어 아키텍처가 가져야 할 **비기능적 품질 요소들**

* 예시:
  - **성능**, **운용성**, **보안성**
  - **시험 용이성**, **가용성**
  - **변경 용이성**, **사용성**

### 프레임워크
* **재사용 가능한 SW 골격 구조**
  - 소프트웨어 기본 구조 제공
  - 개발자의 반복 작업 줄임
  - 재사용성과 생산성 향상

<br>

## 요약 표

| 구분 | 키워드 | 설명 요약 |
|----------------|----------------------------------|-----------|
| 모듈 | 결합도, 응집도 | 좋은 설계는 결합도 낮고, 응집도 높음 |
| 결합도 | 자료, 스탬프, 제어, 외부, 공통, 내용 | 모듈 간 의존도 – 약할수록 좋음 |
| 응집도 | 기능, 순차, 교환, 절차, 시간, 논리, 우연 | 모듈 내부의 집중도 – 강할수록 좋음 |
| 아키텍처 패턴  | 계층형, MVC, 클라이언트-서버, P2P 등 | 시스템 설계 방식의 대표 구조들 |
| 품질 속성 | 성능, 보안성, 가용성, 변경 용이성 등 | 아키텍처가 갖춰야 할 비기능 요건 |
| 프레임워크 | 구조 제공, 재사용성 | SW 기본 뼈대를 제공하는 재사용 가능한 틀 |

<br>

# 📘 객체지향 프로그래밍 & 디자인 패턴 (정보처리기사 1과목 - 소프트웨어 설계)

<br>

## 1. 객체지향 프로그래밍 (Object-Oriented Programming)

* 현실 세계의 객체 개념을 소프트웨어에 반영
* **클래스와 객체** 기반 설계

### 오버로딩(Overloading)
* **한 클래스 내**에서 같은 이름의 메서드를 **매개변수 다르게** 정의
* 비유: 같은 이름의 가게지만, 메뉴나 가격이 다른 것

### 오버라이딩(Overriding)
* **상위 클래스의 메서드**를 **하위 클래스가 재정의**
* 비유: 부모가 정한 규칙을 자식이 바꾸는 것

### 설계 원칙 (SOLID 등)
* 좋은 객체지향 설계를 위한 원칙들:
  - **단일 책임 원칙**: 하나의 클래스는 하나의 책임만
  - **개방-폐쇄 원칙**: 확장에는 열려 있고, 수정에는 닫혀야
  - **리스코프 치환 원칙**: 자식 클래스는 부모를 대체 가능해야
  - **인터페이스 분리 원칙**: 인터페이스는 작게 분리
  - **의존 역전 원칙**: 추상에 의존하고, 구체에 의존하지 말 것

### 구성 요소
* **Class**: 설계도
* **Object**: 실체 (속성: Attribute, 동작: Method)
* **Message**: 객체 간 **메서드 호출** 또는 **데이터 전달**

### 주요 특징
* **캡슐화**: 데이터 은닉 + 접근 제어
* **정보 은닉**: 불필요한 내부 구조 숨기기
* **추상화**: 핵심 기능만 보이도록
* **상속성**: 부모 클래스 기능 재사용
* **다형성**: 동일한 인터페이스로 다른 동작 수행

### 관계성
* **연관(Association)**: A는 B의 멤버 (`Is Member of`)
* **집단화(Aggregation)**: A는 B의 부분 (`Is Part of`)
* **일반화(Generalization)**: A는 B의 상위 (`Is a` 관계)

---

## 2. 디자인 패턴 (Design Pattern)

* 소프트웨어 설계 시 **자주 사용되는 해결책**을 패턴화

### GoF 패턴 (Gang of Four)
* 객체지향 설계의 **고전적인 23가지 패턴** 제안
* 3가지 분류:

#### ① 구조 패턴
* 클래스/객체 간 구조 정의
* 예: 어댑터, 브리지, 컴포지트, 데코레이터, 퍼사드, 프록시, 플라이웨이트 등

#### ② 행위 패턴
* 객체들 간의 **행위(역할 분담)** 중심
* 예: 책임 연쇄, 명령, 해석자, 반복자, 옵저버, 상태, 전략, 템플릿 메서드, 방문자 등

#### ③ 생성 패턴
* 객체 생성 방식 캡슐화
* 예: 싱글톤, 팩토리 메서드, 추상 팩토리, 프로토타입, 빌더 등

<br>

## 3. 디자인 패턴 요소

### 필수 요소
* **이름(Name)**  
* **문제(Problem)**  
* **배경(Context)**  
* **해법(Solution)**  
* **결과(Consequences)**  

### 추가 요소
* **사례**  
* **샘플 코드**  
* **정당성/근거**  
* **원리 설명**

<br>

## 요약 표

| 구분 | 핵심 키워드 | 설명 요약 |
|----------------|--------------------------------------|-----------|
| 객체지향 특징  | 캡슐화, 상속, 다형성, 정보은닉, 추상화 | OOP의 5대 주요 원리 |
| 오버로딩/오버라이딩 | 메서드 중복 정의 / 메서드 재정의 | 클래스 내부/상속 관계에서 동작 정의 |
| 설계 원칙 | SRP, OCP, LSP, ISP, DIP | SOLID 원칙 기반의 설계 규범 |
| 관계성 | 연관, 집단화, 일반화 | 클래스 간 관계 표현 |
| 디자인 패턴 | 구조, 행위, 생성 패턴 | 재사용 가능한 설계 해법 모음 |
| 패턴 요소 | 이름, 문제, 해법, 결과, 사례 등 | 디자인 패턴 구성 요소 |

<br>

# 📘 인터페이스 시스템 정리 (정보처리기사 1과목 - 소프트웨어 설계)

<br>

## 1. 인터페이스 시스템이란?

* **다양한 시스템, 소프트웨어, 모듈 간 데이터를 주고받기 위한 통신 구조**
* 시스템 간 **연결성과 데이터 교환 방식**을 정의하는 구성 요소

---

## 2. 시스템 구성 (System Structure)

* 시스템 간 인터페이스는 보통 다음 3가지 역할로 구성됨:

| 구성 요소 | 설명 |
|-----------|------|
| **송신(Sender)** | 데이터를 보내는 시스템 |
| **수신(Receiver)** | 데이터를 받는 시스템 |
| **중계(Mediator)** | 송수신 사이에서 중계 역할 (예: 게이트웨이, 브로커 등) |

---

## 3. 연계 기술 (Interface Technology)

* 서로 다른 시스템 간 연결을 위한 기술적 수단들

### 주요 연계 기술

| 기술 | 설명 |
|------|------|
| **Socket** | 양방향 통신을 위한 네트워크 소켓 (TCP/IP 기반 실시간 데이터 전송) |
| **DB Link** | 서로 다른 DB 간 연결하여 직접 질의 수행 (예: Oracle ↔ MySQL) |

---

## 4. 미들웨어 솔루션 (Middleware Solutions)

* **이기종 시스템 간 연계를 돕는 중간 소프트웨어**  
* 송수신의 중계 또는 메시지 전달 기능을 수행

### 대표 미들웨어 솔루션

| 종류 | 설명 |
|------|------|
| **TP-monitor** | 트랜잭션 처리 전용 미들웨어 (고성능/고가용성) |
| **ORB (Object Request Broker)** | 객체 간 메시지 전달 (CORBA 기반) |
| **RPC (Remote Procedure Call)** | 원격지 함수 호출 |
| **Database Middleware** | DB 접근/연동을 돕는 미들웨어 |
| **MOM (Message Oriented Middleware)** | 메시지 큐 기반 비동기 통신 (예: Kafka, RabbitMQ) |
| **WAS (Web Application Server)** | 웹 애플리케이션 구동 서버 (ex. 톰캣, WebLogic) |
| **OTM (Open Transaction Manager)** | 오픈소스 트랜잭션 처리 시스템 |

---

## 요약 표

| 구분 | 키워드 | 설명 요약 |
|------|--------|-----------|
| 시스템 구성 | 송신, 수신, 중계 | 인터페이스 기본 역할 구성 |
| 연계 기술 | Socket, DB Link | 실시간 통신 or DB 연동 |
| 미들웨어 솔루션 | TP-monitor, ORB, RPC, MOM, WAS 등 | 시스템 간 연결성과 데이터 전달 담당 |
